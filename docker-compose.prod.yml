# docker-compose.prod.yml

services:
  frontend:
    image: ${ECR_REGISTRY}/validador-qm-frontend:${IMAGE_TAG}
    container_name: validador_qm_frontend_prod
    restart: always
    ports: ["80:8080"]
    networks: ["validador-net-prod"]
    depends_on: [backend] # n8n ya no es una dependencia directa del frontend

  backend:
    image: ${ECR_REGISTRY}/validador-qm-backend:${IMAGE_TAG}
    container_name: validador_qm_backend_prod
    restart: always
    env_file: [".env.prod"]
    networks: ["validador-net-prod"]
    depends_on: [n8n, postgres]

  n8n:
    # Usamos la imagen que ya est√° en ECR. No la reconstruimos.
    image: 637423427532.dkr.ecr.us-east-1.amazonaws.com/validador-qm-n8n:latest
    container_name: validador_qm_n8n_prod
    restart: always
    env_file: [".env.prod"]
    ports: ["5678:5678"] # Lo exponemos directamente
    environment:
      # Las variables se cargan desde el env_file
      DB_TYPE: postgresdb
      DB_POSTGRESDB_HOST: postgres
      DB_POSTGRESDB_DATABASE: ${POSTGRES_DB}
      DB_POSTGRESDB_USER: ${POSTGRES_USER}
      DB_POSTGRESDB_PASSWORD: ${POSTGRES_PASSWORD}
      N8N_ENCRYPTION_KEY: ${N8N_ENCRYPTION_KEY}
      GENERIC_TIMEZONE: ${GENERIC_TIMEZONE}
    volumes: ["n8n_data_prod:/home/node/.n8n"]
    networks: ["validador-net-prod"]
    depends_on: [postgres]

  postgres:
    image: postgres:13
    container_name: validador_qm_postgres_prod
    restart: always
    env_file: [".env.prod"]
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes: ["postgres_data_prod:/var/lib/postgresql/data"]
    networks: ["validador-net-prod"]

networks:
  validador-net-prod:
    driver: bridge

volumes:
  n8n_data_prod:
  postgres_data_prod: